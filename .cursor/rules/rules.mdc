---
description: Clean Code Implementation and Project Management Best Practices
globs:
  - "**/*.php"
  - "**/*.js"
  - "**/*.ts"
  - "**/*.jsx"
  - "**/*.tsx"
  - "**/*.css"
  - "**/*.sql"
  - "**/*.md"
  - "**/*.json"
  - "**/*.yml"
  - "**/*.yaml"
alwaysApply: true
---

# Clean Code Implementation Techniques

- Use descriptive, intention-revealing names for variables, functions, classes, etc.
- Avoid vague or misleading names to improve readability and maintainability.
- Each function or module should have one clear purpose, following Single Responsibility Principle (SRP).
- Write code that clearly expresses intent to minimize comments; comment "why", not "what".
- Replace magic numbers or strings with named constants for clarity.
- Organize code into layers or modules (routes, controllers, services, models).
- Implement centralized and consistent error handling.
- Use modern language features like async/await for better async operations management (Node/JS).
- Use linters/formatters automatically (PHP-CS-Fixer/PHPCS, ESLint, Prettier).
- Write unit tests to ensure correctness and ease future refactoring.
- Avoid duplications by abstracting repeated logic into reusable functions/classes.
- Enforce coding standards using linters and pre-commit hooks.
- Regularly refactor code for simplicity and reduced technical debt.
- Avoid Emoji on UI and Codebase
- Always Professional UI Layout Positioning, Font, Spacing, and more releants

# PHP (Backend) Standards

- Follow PSR-12 coding style; autoload via Composer where applicable.
- Keep `api/` endpoints thin: validate input, call service in `includes/`, return JSON.
- Use prepared statements via PDO/MySQLi with bound parameters only.
- Centralize DB access in `includes/database.php` or `includes/db.php`; avoid inline SQL in pages.
- Sanitize output in PHP templates; escape HTML by default.
- Avoid mixing large HTML in APIs; APIs must return JSON with proper status codes.

# Database (MySQL)

- Use least-privilege DB users; separate read/write if possible.
- Enforce foreign keys, indexes, and appropriate data types (no oversized VARCHARs).
- Wrap multi-statement changes in transactions; ensure atomicity for financial ops.
- Store timestamps in UTC; convert at the UI.
- Use migrations/versioned SQL in `sql/`; never edit prod schema manually.

# Security & Privacy

- Validate and normalize all request params (type, range, enum).
- Prevent SQLi (prepared statements), XSS (escape output), CSRF (tokens on state-changing forms).
- For file uploads (`uploads/`), validate MIME/extension, size limits, randomize filenames, no direct execution.
- Do not expose internal paths or stack traces; log server-side, return generic errors to clients.
- Keep secrets in environment files (not in VCS). Provide `.env.example`.

# Frontend (JS/CSS)

- Use modular JS in `assets/js/`; avoid inline script in PHP pages.
- Prefer Fetch API with `Content-Type: application/json`; handle non-200 gracefully.
- Debounce/throttle expensive DOM/scroll handlers; avoid blocking UI.
- Keep CSS scoped and organized in `assets/css/`; avoid !important unless necessary.

# Node Blockchain Signer

- Pin Node version (e.g., >=18 LTS) in `blockchain/blockchain-signer/`.
- Keep `abi.json` and contract addresses versioned; never hard-code secrets.
- Use `.env` for RPC URLs/private keys; never commit secrets.
- Add npm scripts for lint/test/build; run `npm ci` in CI for reproducibility.

# API Design

- Consistent JSON envelope: `{ success, data, error }` and proper HTTP status codes.
- Idempotent endpoints for financial operations where applicable.
- Pagination for list endpoints; validate `limit`/`offset` with sane caps.

# Error Handling & Logging

- Centralize error formatting; avoid echoing raw exceptions.
- Log with context (userId, endpoint, requestId); exclude sensitive data.
- Distinguish client vs server errors; map to 4xx/5xx.

# Environment & Configuration

- Separate configs per env (dev/test/prod). Do not hard-code absolute paths.
- Document required env vars; provide sane defaults for local XAMPP.
- Use `.gitignore` for `uploads/`, secrets, vendor caches.

# Testing & QA

- Unit test core services (calculations, ledger, validation).
- Integration tests for critical flows (expenses, funds transfer, approvals).
- Smoke test APIs before release; automate via CI.

# Avoid Deleting Root/Database and Project Safety Best Practices

- Implement database-level safeguards such as triggers to prevent accidental DELETE operations.
- Restrict user permissions in the database and filesystem to limit delete rights to only necessary users.
- Mark critical files and folders as immutable on Linux (`chattr +i`) or read-only on Windows (NTFS permissions).
- Use aliases or safety wrappers for destructive commands (`rm`, `del`) to require confirmation before deletion.
- In IDEs, prefer remove or exclude folder operations that do not physically delete files (e.g., IntelliJ content root removal).
- Regularly back up your database and project files with automated or manual systems.
- Use version control (Git) extensively to track, revert, and protect code changes.
- Separate critical database files or root folders into protected or less accessible locations.
- Educate your team about safe file and database handling practices.
- Automate checks for sensitive actions in CI/CD pipelines or pre-commit hooks.
- Log and audit all destructive operations for traceability and accountability.
- Avoid executing destructive commands/scripts without double confirmation or review.

# General Project Safety and Collaboration

- Define clear roles and responsibilities, especially around database and root access.
- Use project management tools to track changes, deployments, and backups.
- Enforce coding and operational standards with linters, hooks, and automated checks.
- Regular communication, code review, and knowledge sharing reduce accidental errors.
- Design APIs and scripts idempotently to safely handle repeat actions without data loss.
- Keep thorough documentation including database schemas, backup procedures, and file structures.

# Deployment

- Version control everything; use branches and clear commit messages.
- Create safe rollout steps for database migrations (backups first).
- Keep a rollback plan for code and schema changes.

# Project Management and Collaboration

- Define clear project scope, objectives, deliverables, deadlines, and constraints.
- Assign clear roles and responsibilities for team members.
- Use project management tools for task, version, and documentation tracking.
- Practice regular communication, standups, reviews, and retrospectives.
- Design APIs/modules to be idempotent and implement caching/memoization.
- Use code reviews with multiple reviewers and integrate automated checks.
- Employ branching strategies like GitFlow and commit with descriptive messages.
- Maintain detailed project documentation, including API docs and architecture decisions.
- Automate repetitive tasks such as builds, deployments, and code quality checks.
- Use effective communication tools (Slack, Teams) for streamlined interactions.
- Share reusable code snippets consistently.
- Keep audit trails with reasons and author for changes and enforce access controls.
- Adapt conflict resolution styles and encourage collaborative problem-solving.